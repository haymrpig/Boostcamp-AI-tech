# 목차

1. [**벡터**](#1-벡터)
   - 정의
   - 벡터의 종류
   - 벡터의 연산
   - 노름
   - 내적
2. [**행렬**](#2-행렬)
   - 정의
   - 종류
   - 연산

# 1. 벡터

- **정의**

  벡터는 숫자를 원소로 가지는 리스트(list) 또는 배열(array)이며, 공간에서 **원점으로부터 상대적 위치**의 한점을 나타낸다. 

- **벡터의 종류**

  - 열벡터

  $$
  X=\begin{bmatrix}
  x_1\\x_2\\...\\x_n
  \end{bmatrix}
  $$

  - 행벡터
    $$
    X^T=\begin{bmatrix}
    x_1, x_2, ...,x_n
    \end{bmatrix}
    $$

- **벡터의 연산**

  - 스칼라곱

    벡터에 숫자를 곱하면 길이가 변한다. 
    $$
    \alpha X=\begin{bmatrix}
    \alpha x_1\\\alpha x_2\\...\\\alpha x_n
    \end{bmatrix}
    $$

  - 

  - 덧셈 / 뺄셈

    두 벡터의 덧셈 / 뺄셈은 다른 벡터로부터의 **상대적 위치이동**이다. 
    $$
    X=\begin{bmatrix}
    x_1\\x_2\\...\\x_n
    \end{bmatrix},\space
    Y=\begin{bmatrix}
    y_1\\y_2\\...\\y_n
    \end{bmatrix},\space
    X+Y=\begin{bmatrix}
    x_1+y_1\\x_2+y_2\\...\\x_n+y_n
    \end{bmatrix}
    $$
    

  - 성분곱 (Hadamard product)
    $$
    X=\begin{bmatrix}
    x_1\\x_2\\...\\x_n
    \end{bmatrix},\space
    Y=\begin{bmatrix}
    y_1\\y_2\\...\\y_n
    \end{bmatrix},\space
    X\cdot Y=\begin{bmatrix}
    x_1y_1\\x_2y_2\\...\\x_ny_n
    \end{bmatrix}
    $$
    

- **노름**

  원점에서의 거리를 의미한다. ( 차원에 상관없이 정의 가능 )

  노름의 종류에 따라 **기하학적 성질**이 달라지며, L1 노름의 경우 마름모꼴, L2 노름의 경우 원형인 것을 알 수 있다.  ( 학습 진행 시 정규화, 최적화에 이용 )

  L1의 경우, robust하게 학습을 할 때, L2는 라플라스 분사 등에 사용된다. 

  - L1 노름
    $$
    X=\begin{bmatrix}
    x_1\\x_2\\...\\x_n
    \end{bmatrix},\space||X||_1=\sum_{i=1}^d|x_i|
    $$

    ```python
    # code
    x_norm1 = np.abs(x)
    x_norm1 = np.sum(x_norm)
    ```

    

    

  - L2 노름
    $$
    X=\begin{bmatrix}
    x_1\\x_2\\...\\x_n
    \end{bmatrix},\space
    ||X||_2=\sqrt {\sum_{i=1}^d|x_i|^2}
    $$

    ```python
    # code
    x_norm2 = x*x
    x_norm2 = np.sum(x_norm2)
    x_norm2 = np.sqrt(x_norm2)
    ```

    

  - L1, L2를 이용한 두 벡터 사이 거리 계산 

    두 벡터의 거리는 벡터의 뺄셈을 이용한다. 
    $$
    ||x-y||=||y-x||
    $$

  - 두 벡터 사이각

    두 벡터의 사이각은 **L2 노름**만 가능하다. **제 2 코사인 법칙**을 이용한다. 
    $$
    \begin{aligned}
    cos\theta &= \frac {||x||_2^2+||y||_2^2-||x-y||_2^2}{2||x||_2||y||_2}\\
    &=\frac {2<x,y>}{2||x||_2||y||_2},
    \;\;\;\;\;\;\;(\space <x,y> =\sum_{i=1}^dx_iy_i,\space 내적\space )
    \end{aligned}
    $$

    ```python
    # code
    v1 = np.inner(x,y) / (L2_norm(x)*L2_norm(y))
    theta = np.arccos(v1)
    ```

  

- **내적**

  정사영된 벡터의 길이는 코사인 법칙에 의해 아래 식이 되고, 내적은 **정사영된 벡터**의 길이를 벡터 y의 길이만큼 조정한 값이라고 할 수 있다. 

  즉, **두 벡터의 유사도**를 의미한다. 
  $$
  정사영된\; 벡터의\; 길이 = ||x||cos\theta\\
  내적=||x||_2||y||_2cos\theta
  $$



# 2. 행렬

- **정의**

  벡터를 원소로 가지는 **2차원 배열**을 의미한다. (numpy에서는 행이 기본 단위로, 행벡터를 원소로 가진다고 할 수 있다.)

  벡터가 공간에서의 한 점을 의미하면, 행렬은 공간에서 여러 점들을 의미한다. 

- **종류**

  - 전치행렬 (transpose matrix)
    $$
    X=(x_{ij}), \space X^T = (x_{ji})
    $$

  - 역행렬 (inverse matrix)

    어떤 행렬 A와 곱했을 때, 항등 행렬이 나오는 행렬을 의미한다. 정방행렬이며, 행렬식 (determinant)가 0이 아닌 경우에만 계산할 수 있다. 
    $$
    AA^{-1}=A^{-1}A=I
    $$

    ```python
    # code
    np.linalg.inv(x)
    ```

  - 유사역행렬 (pseudo-inverse) 또는 무어펜로즈 역행렬 (Moore-Penrose)

    역행렬을 계산할 수 없는 경우 유사역행렬을 통해 역행렬을 구한다. (아래 식)

    선형모델에선 n이 데이터의 개수, m이 데이터 feature개수라고 생각할 수 있고, 유사역행렬을 이용하여 선형회귀식을 구할 수 있다. 
    $$
    n\geq m인\; 경우,\; A^+=(A^TA)^{-1}A^T\\
    n\leq m인\; 경우,\; A^+=A^T(AA^T)^{-1}
    $$

    ```python
    # code
    np.linalg.pinv(x)
    
    # 라이브러리를 활용한 회귀분석 
    from sklearn.linear_model import LinearRegression
    model = LinearRegression()
    model.fit(x,y)
    y_test = model.predict(x_test)
    
    # Moore-Penrose 역행렬을 이용한 회귀분석
    X_ = np.array([np.append(x,[1]) for x in X])
    beta = np.linalg.pinv(X_) @ y
    y_test = np.append(x,[1]) @ beta
    
    # 두 결과가 다른 이유는 Moore-Penrose의 경우 y절편을 직접 추가하기 때문이다. 
    ```

    

- **연산**

  같은 모양을 가질 경우, 연산이 가능하다. 

  - 덧셈 / 뺄셈
    $$
    X\pm Y=(x_{ij}\pm y_{ij})
    $$

  - 성분곱
    $$
    X\cdot Y=(x_{ij}\pm y_{ij})
    $$

  - 스칼라곱
    $$
    \alpha X = (\alpha x_{ij})
    $$

  - 행렬 곱셈 (matrix multiplication)

    행렬곱을 통해 벡터를 **다른 차원의 공간**으로 보내는 것으로 이해할 수 있다. 

    즉, 주어진 데이터에서 패턴을 추출, 데이터를 압축할 수도 있다. 

    모든 선형변환 (Linear transform)은 행렬곱으로 표현할 수 있다. 
    $$
    x\in R^m, z\in R^n\\
    z=Ax일\; 때,\\ 행렬곱은 \;m차원공간\; x에서\; n차원\; 공간\; z로\; 보내는\; 것이라고\; 이해할\; 수\; 있다.
    $$
    

    i번째 행벡터와 j번째 열벡터 사이의 내적으로 계산한다. 

    (X의 열, Y의 행 개수가 같아야 한다.)
    $$
    XY=(\sum_k x_{ik}y_{kj})
    $$

    ```python
    # code
    X@Y
    # np.inner의 경우는 i번째 행벡터와 j번째 행벡터 사이의 내적을 의미한다. (수학에서의 내적과는 다르다!)
    ```

  

  